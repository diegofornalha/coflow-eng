---
layout: PostLayout
metaTitle: Controle b√°sico de acesso em Cadence
addTitleSuffix: true
metaTags: []
colors: colors-d
date: '2023-01-20'
featuredImage:
  type: ImageBlock
  url: /images/23/01/Controle b√°sico de acesso em Cadence diegofornalha.png
  altText: Controle b√°sico de acesso em Cadence
  caption: >-
    O controle de acesso em contratos inteligentes escritos em Cadence, uma
    linguagem de programa√ß√£o para a plataforma Flow. O controle de acesso √© a
    restri√ß√£o de acesso a campos, fun√ß√µes e tipos em um contrato para
    determinados escopos e usu√°rios e √© importante para evitar vulnerabilidades
    no c√≥digo. O Cadence fornece duas camadas de controle de acesso: baseado em
    palavras-chave e baseado em capacidade. As palavras-chave "pub" e
    "access(all)" permitem que uma declara√ß√£o seja acess√≠vel em todos os
    escopos, enquanto "in" e "access(self)" restringem o acesso a um escopo
    espec√≠fico. O controle de acesso baseado em capacidade permite que um
    contrato conceda ou negue acesso a outros contratos com base em suas
    capacidades espec√≠ficas. √â recomendado que os desenvolvedores tenham um
    entendimento completo do controle de acesso em Cadence antes de implantar
    seus projetos na rede principal.
  width: 800
  height: 450
media:
  type: ImageBlock
  url: /images/23/01/Controle b√°sico de acesso em Cadence diegofornalha.png
  altText: Controle b√°sico de acesso em Cadence
  caption: >-
    O controle de acesso em contratos inteligentes escritos em Cadence, uma
    linguagem de programa√ß√£o para a plataforma Flow. O controle de acesso √© a
    restri√ß√£o de acesso a campos, fun√ß√µes e tipos em um contrato para
    determinados escopos e usu√°rios e √© importante para evitar vulnerabilidades
    no c√≥digo. O Cadence fornece duas camadas de controle de acesso: baseado em
    palavras-chave e baseado em capacidade. As palavras-chave "pub" e
    "access(all)" permitem que uma declara√ß√£o seja acess√≠vel em todos os
    escopos, enquanto "in" e "access(self)" restringem o acesso a um escopo
    espec√≠fico. O controle de acesso baseado em capacidade permite que um
    contrato conceda ou negue acesso a outros contratos com base em suas
    capacidades espec√≠ficas. √â recomendado que os desenvolvedores tenham um
    entendimento completo do controle de acesso em Cadence antes de implantar
    seus projetos na rede principal.
  width: 800
  height: 450
bottomSections:
  - type: CtaSection
    colors: colors-e
    elementId: ''
    backgroundSize: full
    title: CoFlow
    titlePt: CoFlow
    text: >
      Nuestra empresa comparte la misma visi√≥n que Dapper Labs, que es crear
      experiencias l√≠deres en la industria web3 y desarrollar dapps en la cadena
      de bloques Flow que proporcionen a los usuarios una forma sencilla de
      administrar sus activos y usar la cadena de bloques. Nuestra misi√≥n es
      hacer del mundo un lugar m√°s accesible y agradable a trav√©s de la adopci√≥n
      por los consumidores de tecnolog√≠as descentralizadas.
    textPt: >
      Nossa empresa compartilha a mesma vis√£o do Dapper Labs, que √© criar
      experi√™ncias web3 l√≠deres do setor e desenvolver dapps na blockchain da
      Flow que possibilita aos usu√°rios uma maneira simples de gerenciar seus
      ativos e usar o blockchain. Nossa miss√£o √© tornar o mundo um lugar mais
      acess√≠vel e agrad√°vel por meio da ado√ß√£o pelo consumidor de tecnologias
      descentralizadas.
    actions:
      - label: Servidor no Discord
        altText: Entrar no Discord
        url: 'https://discord.com/invite/hT8EpC5mUN'
        showIcon: true
        icon: arrowRight
        style: primary
        type: Button
    backgroundImage: null
    styles:
      self:
        height: auto
        width: narrow
        padding:
          - pt-28
          - pb-28
          - pl-4
          - pr-4
        alignItems: center
        justifyContent: center
        flexDirection: col
      title:
        textAlign: left
      text:
        textAlign: left
      actions:
        justifyContent: flex-start
metaDescription: >-
  O controle de acesso em contratos inteligentes escritos em Cadence, uma
  linguagem de programa√ß√£o para a plataforma Flow. O controle de acesso √© a
  restri√ß√£o de acesso a campos, fun√ß√µes e tipos em um contrato para determinados
  escopos e usu√°rios e √© importante para evitar vulnerabilidades no c√≥digo. O
  Cadence fornece duas camadas de controle de acesso: baseado em palavras-chave
  e baseado em capacidade. As palavras-chave "pub" e "access(all)" permitem que
  uma declara√ß√£o seja acess√≠vel em todos os escopos, enquanto "in" e
  "access(self)" restringem o acesso a um escopo espec√≠fico. O controle de
  acesso baseado em capacidade permite que um contrato conceda ou negue acesso a
  outros contratos com base em suas capacidades espec√≠ficas. √â recomendado que
  os desenvolvedores tenham um entendimento completo do controle de acesso em
  Cadence antes de implantar seus projetos na rede principal.
socialImage: /images/23/01/Controle b√°sico de acesso em Cadence diegofornalha.png
titlePt: Controle b√°sico de acesso em Cadence
excerptBr: >-
  O controle de acesso em contratos inteligentes escritos em Cadence, uma
  linguagem de programa√ß√£o para a plataforma Flow. 
title: Control b√°sico de acceso en Cadence
excerpt: >-
  El control de acceso en contratos inteligentes escritos en Cadence, un
  lenguaje de programaci√≥n para la plataforma Flow.
markdown_content_pt: "![](https://miro.medium.com/max/347/1*M7p33-EGZPFdKcX7oR6mDg.jpeg)\n\nEsto es solo para que el administrador presione. No presione. Por favor. Bonito, por favor.\n\n¬°Llegamos a la segunda semana sin olvidar el blog! ¬°Toma eso, enemigos! \U0001F64C\n\nSi eres nuevo aqu√≠, ¬°bienvenido! Este es un blog semanal sobre Cadence, el nuevo lenguaje de programaci√≥n de vanguardia de Flow para contratos inteligentes. Recomiendo comenzar con mi primer art√≠culo sobre materiales para principiantes antes de leer esto, porque supondr√© que los lectores ya tienen una comprensi√≥n b√°sica de Cadence o simplemente disfrutan de mi estilo de escritura. (¬°Estoy halagado!)\n\n# **¬øQu√© es el control de acceso?**\n\nEl control de acceso es la restricci√≥n de campos, funciones y tipos para determinados √°mbitos y usuarios. Es extremadamente importante que los desarrolladores lo consideren profundamente para asegurarse de que su c√≥digo est√© protegido contra posibles vulnerabilidades. La tecnolog√≠a Blockchain ciertamente ha tenido su parte de errores y haza√±as, y muchos de ellos podr√≠an haberse evitado con un control de acceso m√°s adecuado.\n\nCreo que todo desarrollador debe tener una comprensi√≥n completa del control de acceso de Cadence antes de siquiera pensar en implementar su proyecto en la red principal. ¬°Conozco los altos est√°ndares, pero estamos tratando con cosas de valor real aqu√≠! (y la mayor√≠a de ustedes probablemente no me escuchar√° de todos modos y solo copiar√° el c√≥digo Top Shot sin pensarlo)\n\nA diferencia de la mayor√≠a de los lenguajes, Cadence proporciona dos capas diferentes de control de acceso, ambas incorporadas en el lenguaje:\n\n*   [Control de acceso basado en palabras clave](https://docs.onflow.org/cadence/language/access-control/)\n\n*   [Control de acceso basado en capacidades](https://docs.onflow.org/cadence/language/capability-based-access-control/)\n\nRecomendar√≠a revisar esto antes de leer m√°s en esta publicaci√≥n.\n\nNo proporcionar√© una explicaci√≥n detallada de los diferentes tipos de control de acceso en esta publicaci√≥n, pero hablar√© sobre algunas de las razones para usarlos y algunos ejemplos de c√≥mo se pueden utilizar efectivamente en contratos inteligentes.\n\n# **Dos tipos de control de acceso en Cadence**\n\n## **Control de acceso basado en palabras clave**\n\nEl primer tipo de control de acceso en Cadence es el tipo que la mayor√≠a de ustedes probablemente conoce: el uso de palabras clave para especificar el nivel de acceso de un campo espec√≠fico.\n\nCadence proporciona cuatro palabras clave diferentes para especificar los niveles de acceso. Se requiere que cada campo, funci√≥n y tipo especifique un nivel de acceso.\n\n`pub` o `access(all)` significa que la declaraci√≥n es accesible / visible en todos los √°mbitos. Ambos hacen lo mismo, pero `pub` es m√°s corto, por lo que se recomienda usarlo.\n\nPor ejemplo, un campo p√∫blico en un tipo&#x20;\n\npuede ser accedido utilizando la sintaxis de acceso `(object.field)` en una instancia del tipo en un √°mbito externo. Esto no permite que la declaraci√≥n sea p√∫blicamente modificable.\n\nPor lo tanto, si tuviera este contrato implementado en mi cuenta:\n\n```\n\npub contract HelloWorld {\n    pub let greeting: String\n    pub let greetingsByLanguage: {String: String}\n    pub fun returnGreeting(): String {\n        return self.greeting\n    }\n}\n\n\n```\n\nEn una transacci√≥n o script, cualquier persona que importe el contrato de mi cuenta puede leer el campo `greeting`, el diccionario `greetingsByLanguage` o llamar a la funci√≥n `returnGreeting`, pero no pueden reemplazar todo el valor de estos campos, con una excepci√≥n.\n\nSi hay un diccionario o campo de matriz p√∫blico, incluso si no se puede reemplazar por alguien como esto,\n\n```\n\nHelloWorld.greetingsByLanguage = { // No se puede\n\n```\n\nun elemento a√∫n se puede modificar por alguien como esto.\n\n```\n\nHelloWorld.greetingsByLanguage[\"Espa√±ol\"] = \"Hola\" // posible\n```\n\nPor esta raz√≥n, se recomienda encarecidamente hacer todos los campos en contratos y tipos compuestos privados, `access(self)`, de manera predeterminada. Puedes definir configuradores y getters para tus campos. Veamos c√≥mo se ve esto en el contrato anterior.\n\n```\n\npub contract HelloWorld {\n    pub var _greeting: String\n    pub var _greetingsByLanguage: {String: String}\n\n    init() {\n        self._greeting = \"Hello, World!\"\n        self._greetingsByLanguage = {\n            \"en\": \"Hello\",\n            \"fr\": \"Bonjour\",\n            \"it\": \"Ciao\",\n            \"de\": \"Hallo\"\n        }\n    }\n\n    pub fun returnGreeting(): String {\n        return self._greeting\n    }\n\n    pub fun setGreeting(newGreeting: String) {\n        self._greeting = newGreeting\n    }\n\n    pub fun getGreetingsByLanguage(): {String: String} {\n        return self._greetingsByLanguage\n    }\n\n    pub fun setGreetingsByLanguage(newGreetingsByLanguage: {String: String}) {\n        self._greetingsByLanguage = newGreetingsByLanguage\n    }\n}\n\n```\n\nEn este ejemplo, he hecho los campos `_greeting` y `_greetingsByLanguage` privados y he definido configuradores y getters para ellos. De esta manera, puedo controlar c√≥mo se accede y modifica cada campo.\n\n## **Control de acceso basado en capacidades**\n\nEl segundo tipo de control de acceso en Cadence es el control de acceso basado en capacidades. En lugar de utilizar palabras clave para controlar el acceso, este enfoque utiliza capacidades para restringir el acceso.\n\nEn resumen, una capacidad es un objeto que se utiliza para identificar y controlar el acceso a un recurso. Solo los objetos que tienen una capacidad para un recurso pueden acceder a √©l. Si un objeto no tiene una capacidad para un recurso, no puede acceder a √©l.\n\nPara usar el control de acceso basado en capacidades en Cadence, primero debes definir la estructura de capacidad. Esta estructura debe incluir campos para identificar el recurso y el permiso asociado con la capacidad. Por ejemplo, aqu√≠ hay una estructura de capacidad simple para controlar el acceso a una cuenta:\n\n```\n\nstruct AccountCapability {\n    let accountID: String\n    let capability: Capability<&AnyResource{Account}>\n}\n\n```\n\nEn este ejemplo, la estructura `AccountCapability` contiene dos campos p√∫blicos: \"canDeposit\" y \"canWithdraw\". Ambos campos son de tipo booleano, lo que significa que solo pueden tener dos posibles valores: verdadero o falso.\n\nEl campo \"canDeposit\" indica si el titular de la cuenta puede hacer dep√≥sitos, mientras que el campo \"canWithdraw\" indica si el titular de la cuenta puede hacer retiros. Estos campos p√∫blicos son √∫tiles porque permiten a otros objetos interactuar con la estructura AccountCapability y determinar qu√© acciones son posibles para un determinado titular de cuenta.\n\nAdem√°s, al hacer que estos campos sean p√∫blicos, se hace m√°s f√°cil el acceso a ellos desde otros objetos. En otros casos, podr√≠a ser necesario agregar m√©todos a la estructura para obtener o establecer los valores de estos campos, lo que agregar√≠a una complejidad adicional.\n\nEn general, el uso de campos p√∫blicos en estructuras o clases debe ser cuidadosamente considerado. Si los campos representan informaci√≥n que es cr√≠tica para el correcto funcionamiento del objeto, entonces es posible que sea mejor mantenerlos como privados y proporcionar m√©todos para acceder a ellos. Sin embargo, en otros casos, puede ser apropiado hacer que los campos sean p√∫blicos para facilitar el acceso y la interoperabilidad con otros objetos.\n"
author: content/data/team/people/diego-fornalha.json
---
![https://miro.medium.com/max/347/1\*M7p33-EGZPFdKcX7oR6mDg.jpeg](https://miro.medium.com/max/347/1\*M7p33-EGZPFdKcX7oR6mDg.jpeg)

Isso √© apenas para o administrador pressionar. N√£o pressione. Por favor. Pretty Please

Chegamos √† segunda semana sem esquecer o blog! Pegue isso, inimigos! üôå

Se voc√™ √© novo aqui, seja bem-vindo! Este √© um blog semanal sobre o Cadence, o novo idioma de ponta do Flow para contratos inteligentes. Eu recomendo come√ßar com¬†[meu primeiro post sobre materiais para iniciantes](https://joshuahannan.medium.com/taking-your-first-steps-with-cadence-19dde86bbd0)¬†antes de ler isso, porque assumirei que os leitores j√° t√™m um entendimento b√°sico de Cadence ou simplesmente apreciam meu estilo de escrita. ( Estou lisonjeado! )

# **O que √© controle de acesso?**

Controle de acesso √© a restri√ß√£o de campos, fun√ß√µes e tipos para determinados escopos e usu√°rios. √â extremamente importante que os desenvolvedores considerem profundamente para garantir que seu c√≥digo seja protegido contra poss√≠veis vulnerabilidades. Tecnologia Blockchain certamente¬†[teve seu quinh√£o de bugs e fa√ßanhas](https://forum.openzeppelin.com/t/list-of-ethereum-smart-contracts-post-mortems/1191)¬†e muitos deles poderiam ter sido impedidos com um controle de acesso mais bem gerenciado.

Acredito que todo desenvolvedor deve ter um entendimento completo do controle de acesso Cadence antes mesmo de pensar em implantar seu projeto na rede principal. Altos padr√µes que conhe√ßo, mas estamos lidando com coisas com valor real aqui! ( e a maioria de voc√™s provavelmente n√£o vai me ouvir de qualquer maneira e apenas copie o c√≥digo Top Shot sem pensar nele )

Ao contr√°rio da maioria dos idiomas, o Cadence fornece duas camadas diferentes de controle de acesso, ambas incorporadas ao idioma:

*   [Controle de acesso baseado em palavras-chave](https://docs.onflow.org/cadence/language/access-control/)
*   [Controle de acesso baseado em capacidade](https://docs.onflow.org/cadence/language/capability-based-access-control/)

Eu recomendaria conferir isso antes de ler mais desta postagem.

N√£o vou fornecer uma explica√ß√£o detalhada dos diferentes tipos de controle de acesso neste post, mas vou falar sobre alguns dos motivos para utiliz√°-los, e alguns exemplos de como eles podem ser usados efetivamente em contratos inteligentes.

# **Dois tipos de controle de acesso em Cadence**

## **Controle de acesso por palavra-chave**

O primeiro tipo de controle de acesso em Cadence √© o tipo com o qual a maioria de voc√™s provavelmente conhece: Usando palavras-chave para especificar o n√≠vel de acesso de um campo espec√≠fico.

O Cadence fornece quatro palavras-chave diferentes para especificar os n√≠veis de acesso. Cada campo, fun√ß√£o e tipo √© necess√°rio para especificar um n√≠vel de acesso.

`pub`¬†ou¬†`access(all)`¬†significa que a declara√ß√£o √© acess√≠vel / vis√≠vel em todos os escopos. Cada um faz a mesma coisa, mas¬†`pub`¬†√© mais curto, por isso √© recomend√°vel usar.

Por exemplo, um campo p√∫blico em um tipo pode ser acessado usando a sintaxe de acesso¬†`(`object.field`)`¬†em uma inst√¢ncia do tipo em um escopo externo. Isso n√£o permite que a declara√ß√£o seja publicamente grav√°vel.

Portanto, se eu tivesse esse contrato implantado na minha conta:

```
contrato de pub HelloWorld {    pub let sauda√ß√£o: Cordas    pub let sauda√ß√µesByLanguage: { String: String }    retorno divertido do pubGreeting ( ): Corda {
        retornar self.greeting
    }}
```

Em uma transa√ß√£o ou script, qualquer pessoa que importe o contrato da minha conta poder√° ler o¬†`greeting`¬†campo,¬†`greetingsByLanguage`¬†dicion√°rio ou ligue para o¬†`returnGreeting`¬†fun√ß√£o, mas eles n√£o podem substituir o valor inteiro nesses campos, com uma exce√ß√£o.

Se houver um dicion√°rio p√∫blico ou campo de matriz, mesmo que n√£o possa ser substitu√≠do por algu√©m como este,

```
HelloWorld.greetingsByLanguage = { // N√£o √© poss√≠vel
```

um elemento ainda pode ser modificado por algu√©m como este.

```
HelloWorld.greetingsByLanguage [ "Espa√±ol" ] = "Hola" // poss√≠vel
```

Por esse motivo, √© altamente recomend√°vel tornar todos os campos em contratos e tipos compostos privados,¬†`access(self)`, por padr√£o. Voc√™ pode definir configuradores e getters para seus campos. Vamos ver como isso se parece no contrato anterior.

```
contrato de pub HelloWorld {    access ( self ) let greeting: String    access ( self ) let greetingsByLanguage: { String: String }    retorno divertido do pubGreeting ( ): Corda {
        retornar self.greeting
    }    pub fun returnLanguageGreeting ( _ idioma: String ): String? {
        retornar self.greetingsByLanguage [ language ]
    }}
```

Isso usa¬†`access(self)`, o que significa que a declara√ß√£o √© acess√≠vel / vis√≠vel apenas nos escopos atual e interno. Por exemplo, um¬†`access(self)`¬†O campo s√≥ pode ser acessado por fun√ß√µes do tipo que fazem parte, n√£o por c√≥digo em um escopo externo. Isso permite que o desenvolvedor seja capaz de definir explicitamente como seus campos s√£o acessados por getters e setters.

As outras duas palavras-chave de acesso s√£o um pouco exclusivas da Cadence.

`access(contract)`significa que a declara√ß√£o √© acess√≠vel / vis√≠vel apenas no escopo do contrato que a definiu. Isso significa que outros tipos e fun√ß√µes definidos no mesmo contrato podem acess√°-lo, mas n√£o outros contratos na mesma conta.

Voc√™ poderia ter algo assim:

```
contrato de pub HelloWorld {    pub struct Ol√° {        acesso ( contrato ) var sauda√ß√£o: corda    }    pub fun returnGreeting ( _ ol√°: Ol√° ): Corda {
        voltar ol√°.
    }}
```

Nesta situa√ß√£o, se voc√™ tivesse uma inst√¢ncia do¬†`Hello`¬†struct, voc√™ n√£o seria capaz de obter diretamente o¬†`greeting`¬†campo usando¬†`Hello.greeting`, mas desde o¬†`returnGreeting`¬†fun√ß√£o √© definida no mesmo contrato, voc√™ pode dar a ela¬†`Hello`¬†estruture e obtenha o¬†`greeting`¬†campo dessa maneira:

```
Ol√°, Ol√°, Ol√°, Ol√°, Ol√°, Ol√°, = "hola" (// inv√°lido porque o campo √© contrato de acesso
deixe sauda√ß√£o = helloObject.greeting// V√°lido: a fun√ß√£o de contrato pode acessar o campo e
// devolv√™-lo
deixe a sauda√ß√£o = HelloWorld.returnGreeting ( helloObject )// sauda√ß√£o √© "hola"
```

Este √© apenas um exemplo simples, mas tenho certeza de que voc√™ pode imaginar uma utiliza√ß√£o mais sofisticada dessa capacidade.

`access(account)`significa que a declara√ß√£o √© acess√≠vel / vis√≠vel apenas no escopo de toda a conta onde √© definida. As contas de fluxo podem ter qualquer n√∫mero de contratos de cad√™ncia implantados para eles, portanto, essa palavra-chave significa que quaisquer outros contratos na mesma conta podem acess√°-lo.

Com este campo, voc√™ pode declarar campos em contratos como¬†`access(account)`¬†, sabendo que voc√™ deseja que eles sejam ‚Äú privados ‚Äù por enquanto, mas mantendo aberta a possibilidade de implantar um novo contrato posteriormente que possa interagir com o primeiro contrato de novas maneiras. Voc√™ tamb√©m pode manter seus contratos mais simples, agrupando apenas funcionalidades semelhantes em um contrato, mas tendo contratos relacionados ainda na mesma conta que podem compartilhar algumas informa√ß√µes entre si.

Essa palavra-chave √© a que tenho menos experi√™ncia em usar, mas recentemente tenho pensado em mais maneiras de us√°-la. Se voc√™ tiver algum exemplo de onde o usou, deixe um coment√°rio e me avise!

## **Controle de acesso baseado em capacidade**

A outra forma principal de controle de acesso em Cadence utiliza¬†[Seguran√ßa baseada em capacidade](https://en.wikipedia.org/wiki/Capability-based_security), um modelo de seguran√ßa que n√£o √© usado com muita frequ√™ncia. A maioria dos modelos de seguran√ßa ( e a maioria das outras linguagens de programa√ß√£o de contratos inteligentes ) restringem o acesso com base em¬†*quem voc√™ √©*, mas a seguran√ßa da capacidade √© mais sobre¬†*o que voc√™ possui*.

Vamos olhar para uma analogia:

![https://miro.medium.com/max/700/1\*uAtIjsm7b2QMc2f7bknWOg.png](https://miro.medium.com/max/700/1\*uAtIjsm7b2QMc2f7bknWOg.png)

tantas escolhas!

Imagem que voc√™ est√° projetando um dispositivo f√≠sico para o governo usar para gerenciar o acesso a importantes funcionalidades internas, como imprimir dinheiro, declarar guerra, pagar impostos etc. Todos no pa√≠s precisam ter acesso a algum subconjunto dessa funcionalidade, mas a especifica√ß√£o de acesso de cada pessoa √© diferente de muitas das outras pessoas. Por exemplo, todos precisam ter acesso √† funcionalidade ‚Äú pagar impostos ‚Äù, mas apenas funcion√°rios eleitos do governo precisam ter acesso √† ‚Äú declarar guerra ‚Äù e assim por diante.

Se estiv√©ssemos projetando esse sistema da maneira que a maioria dos contratos inteligentes gerencia o acesso, com uma lista que indica quem tem acesso a qu√™, ent√£o esse dispositivo f√≠sico se pareceria com uma placa de controle gigante em um local p√∫blico com milhares de bot√µes diferentes para cada funcionalidade sobre a qual o governo tem algum controle. Qualquer pessoa na Terra seria capaz de caminhar at√© este quadro e pressionar qualquer um dos bot√µes, mas o bot√£o executaria algum tipo de varredura biom√©trica ( como uma varredura de √≠ris ou impress√£o digital ) para verificar se essa pessoa tem autoridade para executar a a√ß√£o. Se eles passarem na verifica√ß√£o, a funcionalidade acontecer√°. Existe at√© um bot√£o p√∫blico para alterar as regras de acesso!

Este √© um exemplo artificial, mas tenho certeza de que voc√™ pode ver os problemas com isso. Se algum dos bot√µes n√£o foi projetado corretamente ou est√° com defeito, qualquer pessoa na Terra seria capaz de explorar o bot√£o quebrado para fazer coisas que n√£o deveria!

Uma solu√ß√£o mais eficaz para esse problema seria fornecer a cada cidad√£o um dispositivo que contenha apenas os bot√µes de funcionalidade que eles podem acessar. Em seguida, cada cidad√£o armazena esse dispositivo em um local seguro em sua casa ou seguro que somente eles podem acessar. Agora, se houver uma vulnerabilidade em um dos bot√µes, um invasor tem a dif√≠cil tarefa de invadir cada casa dos participantes e se proteger individualmente, o que √© muito mais dif√≠cil e demorado.

√â isso que os recursos realizam em Cadence. Em vez de criar uma lista especial de controle de acesso com regras opacas e complexas, o controle de acesso √© incorporado aos fundamentos do sistema de tipos Cadence. Os usu√°rios obt√™m objetos de recursos especiais que armazenam em sua conta que definem qual funcionalidade eles podem acessar.

Usando o exemplo acima, criar√≠amos um¬†`HelloAdmin`¬†recurso que permite ao propriet√°rio atualizar o¬†`greeting`¬†campo:

```
contrato de pub HelloWorld {    // Isso precisa ser um acesso ( contract ) para que o recurso definido em
    // o mesmo contrato pode acess√°-lo
    acesso ( contrato ) var sauda√ß√£o: corda    retorno divertido do pubGreeting ( ): Corda {
        retornar self.greeting
    }    // Somente o propriet√°rio deste objeto de recurso pode chamar essa fun√ß√£o
    recurso de pub HelloAdmin {
        pub fun modificGreeting ( _ newGreeting: String ) {
            HelloWorld.greeting = newGreeting
        }
    }
}
```

Os atacantes nem sequer teriam a oportunidade de explorar muitos bugs em potencial, porque o c√≥digo nem sequer √© acess√≠vel a eles para tentar explorar em primeiro lugar!

Os recursos s√£o um assunto complexo, e estou planejando fazer uma postagem no blog no futuro que seja completamente dedicada a eles. Por enquanto, eu recomendaria verificar¬†[post deste blog](https://medium.com/@kleffew/what-is-capability-based-security-227c6e5483a5)¬†sobre recursos gen√©ricos e¬†[Documenta√ß√£o de capacidade de cad√™ncia](https://docs.onflow.org/cadence/language/capability-based-access-control/).

# **Conclus√£o**

Espero ter deixado alguns dos recursos de controle de acesso do Cadence um pouco mais claros para voc√™.

Compartilhe todos os usos interessantes dos recursos de controle de acesso da Cadence que voc√™ fez ou viu outros implementarem!

Se voc√™ tiver alguma d√∫vida, toda a equipe e comunidade do Flow est√° aqui para apoi√°-lo! N√£o hesite em entrar em contato com nosso servidor Discord, o Flow Forum ou atrav√©s de um problema no repo Flow Github.

Existem outros t√≥picos ou projetos interessantes que voc√™ sabe que seriam √∫teis para os rec√©m-chegados ou sobre os quais voc√™ gostaria que eu escrevesse uma postagem no blog? Sinta-se √† vontade para comentar com suas id√©ias e eu posso inclu√≠-las em um post futuro!

Artigo original em ingl√™s: https://joshuahannan.medium.com/basic-access-control-in-cadence-28c5765c6ec0
